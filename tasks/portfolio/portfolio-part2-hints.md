## Советы по выполнению задания Portfolio#2-Адаптивная вёрстка
- [Описание и требования задания Portfolio#2-Адаптивная вёрстка](portfolio-part2.md)

1. [Adaptive Design](#adaptive-design)
2. [Metateg viewport](#metateg-viewport)
3. [Media Queries](#media-queries)
4. [CSS variables](#css-variables)
5. [calc()](#calc)
6. [Adaptive menu](#adaptive-menu)

### Adaptive Design
Адаптивная вёрстка позволяет сайту хорошо выглядеть при любом разрешении экрана.  
Основное требование к адаптивной вёрстке - оптимальные размер и расположение элементов и отсутствие на сайте горизонтальной полосы прокрутки вне зависимости от того, просмотривают его на десктопе, планшете или мобильном устройстве.  

Для адаптивного сайта дизайнер отрисовывает несколько макетов страницы для компьютеров, планшетов и смартфонов. Разработчик при вёрстке указывает для каждого макета разрешение экрана и задаёт соответствующие ему размеры элементов и отступы между ними. Когда пользователь заходит на сайт, он видит только тот интерфейс, который соответствует ширине экрана его устройства.

Другим способом обеспечить правильное отображение страницы на разных устройствах является респонсивный (резиновый) дизайн, при котором размеры задают в процентах от ширины экрана. При респонсивном дизайне уменьшении ширины страницы сопровождается плавным изменением размеров элементов.

Как правило, в разработке совмещают оба эти подхода: при изменении ширины страницы какие-то элементы изменяются плавно, другие скачкообразно.

### Metateg viewport

В тег <head> html-кода необходимо вложить метатег viewport (при создании основы html-файла VS Code его добавляет автоматически)
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

В этой строке мы указываем, что ширина видимой области равна ширине устройства, а изначального масштабирования нет. Чаще всего это оптимальный сценарий работы страницы.

### Media Queries
Адаптивная вёрстка достигается при помощи медиазапросов. Медиазапросы позволяют определять внешний вид веб-страниц в зависимости от ширины окна браузера. 

При помощи медиа-запросов можно создавать так называемые контрольные точки (англ. breakpoints) и привязывать к ним CSS-стили.

Если речь о подходе `Desktop-First`, который реализуется в данном макете, в нём стили пишутся от большего к меньшему и используются медиазапросы, в которых указывается максимальная ширина экрана, к которой применяются указанные стили:

```css
@media (max-width: 1440px) {
  .skills-items {
    justify-content: space-around;
  }
}
```

Код выше означает, что при ширине экрана до 1440px элементы внутри блока `skills-items` размещаются с равными отступами между собой и краями контейнера. В предыдущей части советов  писали о том, что при ширине экрана большей 1440px в данном блоке размещение вложенных элементов управляется свойством `justify-content: space-between` - вложенные элементы прижаты к краям родителя. 

В медиазапросах указываем только те свойства элементов, которые изменились для указанной ширины экрана.

Чаще всего в медиазапросах изменяются:
- количество колонок
- размеры элементов
- отступы
- размер шрифта
- отдельные элементы могут скрываться
- добавляется адаптивное меню

### CSS variables
Если в css-коде страницы вы использовали css-переменные, их будет удобно и быстро изменить при помощи медиа-запросов. Вместо того, чтобы изменять значения отступов или размер шрифта каждого элемента, достаточно один раз его изменить в псевдоклассе `:root`.  
Например (здесь и дальше все числа произвольные):

```css
:root {
  --font1: 80px;
  --padding: 75px;
}
@media (max-width: 1024px) {
  :root {
    --font1: 50px;
    --padding: 60px;
}
@media (max-width: 796px) {
  :root {
    --font1: 40px;
    --padding: 40px;
  }
}
```

### calc()

Функция calc() позволяет рассчитать значения css-свойств. При адаптивной вёрстке использование функции calc() позволяет обеспечить плавное изменение размеров элементов при изменении ширины страницы, совместить адаптивный и респонсивный дизайн.  
Например:  
```css
.video-player {
  width: 100%;
  max-width: 1400px;
  height: calc(46% + 60px);
  max-height: 705px;
}
```  
В примере выше видеоплеер занимает всю ширину контейнера, но не больше 1400рх.  
Высота видеоплеера составляет 46% от его ширины плюс 60рх - высота панели управления.

### Adaptive menu

Адаптивное меню ещё называют бургер-меню из-за иконки-гамбургера при клике по которой оно открывается и закрывается.

Эта иконка присутствует в html-разметке не только на мобильных, но и на десктопных разрешениях, но там она скрыта свойством `display: none;`. А когда экран становится уже и все пункты меню в него перестают помещаться, необходимо навигацию спрятать всё тем же свойством `display: none`, а гамбургер, наоборот, отобразить свойством `display: block` или `display: flex`.

[Примеры анимированных гамбургер-иконок с codepen](https://codepen.io/RRoberts/full/ZBYaJr)  
[Простая анимированная гамбургер-иконка](https://codepen.io/irinainina/full/Jjryqav)

Пока ничего сложного не было. Следующий шаг - для указанных в макете разрешений изменить стили адаптивного меню, чтобы в открытом виде оно выглядело так, как на макете. Указать ширину и высоту, свойством `flex-direction: column;` выстроить пункты меню в колонку, добавить оформление.

Последний пункт - кликом по иконке-гамбургеру добавлять или удалять адаптивному меню класс `open` и изменять вид самой иконки.  

Открытие и закрытие адаптивного меню можно реализовать и без js, только средствами css, но такое меню сложнее в реализации.  
[Пример адаптивного меню на чистом css](https://codepen.io/Joanc/full/XYYZdE) 

Программирование - борьба со сложностью.  
То, что средствами css занимает десятки строк, средствами js требует существенно меньше кода, причём кода понятного и простого.

Для добавления или удаления у адаптивного меню класса `open` идеально подойдёт метод `classList.toggle()`. Если класс у элемента отсутствует, метод `classList.toggle()` этот класс добавляет, иначе - убирает.  

Таким образом, js-код для открытия и закрытия адаптивного меню состоит буквально из нескольких строчек:  
- при помощи метода `document.querySelector()` находим на странице иконку-гамбургер и адаптивное меню
- отслеживаем клики по иконке при помощи метода `hamburger.addEventListener('click', toggleMenu)`
- пишем код функции `toggleMenu`, которая меняет класс `'open'` у иконки и меню - добавляет, если класса нет и убирает, если класс есть
- в css нужно прописать разные стили для иконки и меню в зависимости от того есть у них класс `'open'` или этого класса нет

И самый-самый последний пункт - обеспечить красивое плавное появление и скрытие адаптивного меню.  
Чтобы меню плавно выезжало сбоку, указываем ему абсолютное позиционирование, значение z-index, чтобы меню располагалось поверх остальных элементов и положение по горизонтали за границей экрана. Если, например, ширина адаптивного меню 420рх, свойство `left: -420px;` разместит его за левой границей экрана. Чтобы при этом не появилась полоса прокрутки, контейнеру, внутри которого размещается меню, указываем свойство `overflow-x: hidden;`. Чтобы меню появилось, достаточно классу `open` указать свойство `left: 0;`, а чтобы появление происходило плавно, используем свойство `transition: 0.5s`.